package org.jooq.mcve.test.java.postgres;

import org.jooq.*;
import org.jooq.Record1;
import org.jooq.SQLDialect;
import org.jooq.impl.DSL;
import org.jooq.mcve.java.postgres.tables.records.TestRecord;
import org.jooq.tools.JooqLogger;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.utility.ResourceReaper;

import java.io.Serializable;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

import static org.jooq.mcve.java.postgres.Tables.TEST;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;

public class JavaTest {

    static JooqLogger log = JooqLogger.getLogger(JavaTest.class);
    static PostgreSQLContainer<?> db;
    static Connection connection;
    static DSLContext ctx;

    @BeforeClass
    public static void init() throws SQLException {
        if (System.getProperty("db.url") == null) {
            db = new org.testcontainers.containers.PostgreSQLContainer<>("postgres:latest")
                    .withUsername("postgres")
                    .withDatabaseName("postgres")
                    .withPassword("postgres")
                    .withInitScript("/db/migration/init.sql");

            db.start();
            System.setProperty("db.url", db.getJdbcUrl());
            System.setProperty("db.username", db.getUsername());
            System.setProperty("db.password", db.getPassword());
        }

        Properties properties = new Properties();
        properties.setProperty("username", "postgres");
        properties.setProperty("password", "postgres");

        log.info("Connecting");
        connection = DriverManager.getConnection(
                System.getProperty("db.url"),
                System.getProperty("db.username"),
                System.getProperty("db.password")
        );

        ctx = DSL.using(connection, SQLDialect.POSTGRES);

        // Use JDBC directly instead of jOOQ to avoid DEBUG logging all of this
        try (Statement s = connection.createStatement()) {
            log.info("Finished setup");
        }
    }

    @AfterClass
    public static void end() {
        if (db != null) {
            ResourceReaper.instance().stopAndRemoveContainer(db.getContainerId(), db.getDockerImageName());
        }
    }

    @Before
    public void setup() throws Exception {
        ctx.delete(TEST).execute();
    }

    @After
    public void after() throws Exception {
    }

    @Test
    public void mcveTest() {
        assertEquals(1,
                ctx.insertInto(TEST)
                        .columns(TEST.CD)
                        .values(42)
                        .execute()
        );

        TestRecord record = ctx.fetchOne(TEST, TEST.CD.eq(42));

        Integer id = Integer.valueOf(1);

        // 1. Fetching the plain result
        // GOOD - VALUES ARE PRESENT
        Record1<TestRecord> fetchOne = ctx.select(TEST).from(TEST).where(TEST.ID.eq(id)).fetchOne();
        log.info("fetchOne:");
        log.info(fetchOne);

        // 2. Fetching into a POJO
        // GOOD
        org.jooq.mcve.java.postgres.tables.pojos.Test fetchOneInto_POJO =
            ctx.select(TEST)
                .from(TEST)
                .where(TEST.ID.eq(id))
                .fetchOneInto(org.jooq.mcve.java.postgres.tables.pojos.Test.class);
        log.info("fetchOneInto_POJO:");
        log.info(fetchOneInto_POJO);

        // 3. Fetching into the TableRecord
        // BAD: All values in the record are null.
        TestRecord fetchOneInto_TableRecord =
            ctx.select(TEST).from(TEST).where(TEST.ID.eq(id)).fetchOneInto(TestRecord.class);
        log.info("fetchOneInto_TableRecord:");
        log.info(fetchOneInto_TableRecord);

        // 4. Fetching into the Table
        // BAD: All values in the record are null.
        TestRecord fetchOneInto_Table = ctx.select(TEST).from(TEST).where(TEST.ID.eq(id)).fetchOneInto(TEST);
        log.info("fetchOneInto_Table:");
        log.info(fetchOneInto_Table);

        // 5. Using get, mapping into the TableRecord
        // GOOD
        TestRecord fetchOne_Get0_TestRecord =
            ctx.select(TEST).from(TEST).where(TEST.ID.eq(id)).fetchOne().get(0, TestRecord.class);
        log.info("fetchOne_Get0_TestRecord:");
        log.info(fetchOne_Get0_TestRecord);

        // 5.a) Using get(Name), mapping into the TableRecord
        // GOOD
        TestRecord fetchOne_GetName_TestRecord =
            ctx.select(TEST).from(TEST).where(TEST.ID.eq(id)).fetchOne().get(TEST.getQualifiedName(), TestRecord.class);
        log.info("fetchOne_GetName_TestRecord:");
        log.info(fetchOne_GetName_TestRecord);

        assertNotNull(record.getId());
    }

}
